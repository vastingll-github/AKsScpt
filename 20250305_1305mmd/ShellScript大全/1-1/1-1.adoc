

== シェルスクリプト内のコマンド結果（返却値）判定でエラー処理を書かないために！


[[personal-public-article-body]]
== #はじめに

`[ $? -eq 0 ]` や `[ $? -ne 0]`
を記述することはよくある書き方だが冗長で、1979年にBourneシェル公開時からこの書き方はなかった。

=== **目指すは無駄がないシンプルなコード** （以下の文がむだかな）
* 丁寧なコードとは無駄な処理を書くことではありません。 

`[ $? -eq 0 ]や [ $? -ne 0 ]`
は書かないほうがShell-Scriptor自身が楽で、第三者の目には読みやすくなります。
優れた文法を持つシェルは短いコードで正しく動作し、良い書き方は最短の時間と最小の手間で目的を達成することですね。
コマンドのエラー処理を簡潔に書くことが、シェル言語の優れた点の一つでシェルスクリプトを書く理由です。

本資料は主に `if` について書きますが `while` や `until`
も当てはまります。また `set -e` (errexit)　を設定してスクリプトを実行すると
中で記述する、パイプライン、リスト、または複合コマンドが 0以外（Shellでは０が正常、それ以外は異常）のステータスで終了した場合、直ちに終了します。

失敗したコマンドが while または untilの直後のコマンドリストの一部や、 +
予約語 if または elif に続くテストの一部である場合、 +
&& または || リスト内で実行されたコマンド (最後の && または || に続くコマンドを除く)の一部である場合、 +
パイプライン内の最後以外のコマンドである場合、 +
またはコマンドの戻り値が ! で反転されている場合は、 +
シェルは終了しません。

シェルスクリプト内でサブシェル以外の複合コマンドが、 -e設定時 パイプライン等内である返却値0でも無視されている間は、コマンドが失敗してもシェルは終了しません。

ERRトラップ（２章で紹介）が設定されている場合は、シェルが終了する前に実行されます。このオプションは、シェル環境と各サブシェル環境に個別に適用されます。

また、サブシェル内（スクリプト内でコマンド実行はサブシェルを起動して実行する）のすべてのコマンドを実行する前にサブシェルが終了する可能性があります。 -e が無視されるコンテキストで複合コマンドまたはシェル関数が実行された場合、-e が設定されていてコマンドが失敗しても、複合コマンドまたは関数本体内で実行されるコマンドはいずれも -e設定の影響を受けません。-eが無視されるコンテキストで複合コマンドまたはシェル関数が -eを設定して実行した場合、その設定は複合コマンドまたは関数呼び出しを含むコマンドが完了するまで有効になりません。


を使うことでもっと簡潔に書くことが出来ますが、補足説明が多くなってしまい話がぶれてしまうので省略します。
この章・項・節のうちの項での論点は
`[ $? -eq 0 ]` や `[ $? -ne 0 ]`
を記述しないことです。

== [**書き方** 
百聞は一見にしかず、以下です。（むだかな面白みがないかな？）

[NOTE]
====
シンプルイズビューティフル

....
if cp from to; then
  echo "コピーに成功しました"
else
  echo "コピーに失敗しました"
fi
....
====

[NOTE]
====
# 失敗したときだけ処理を行う場合
# （補足: POSIXで標準化されているが、Bourneシェル #!/usr/bin/sh は非対応）
....
if ! cp from to; then
  echo "コピーに失敗しました"
fi
....
====

これはBourne シェル（sh）の書き方じゃありません。
**Bourneシェルの開発者が公式に解説している `if` の典型的な使い方**です。
後者の`!` を使った書き方は sh では非対応で、`!` は 1992 年の POSIX で標準化されており現在の シェル はすべて対応しています。

以下は `[ $? -eq 0 ]` を使った無駄なことをしているコードです。Bourne
シェルの開発者による解説にはこのようなコードは出てきません。

[NOTE]
====
冗長でデメリットあり

....
cp from to
if [ $? -eq 0 ]; then
  echo "コピーに成功しました"
else
  echo "コピーに失敗しました"
fi
....
====

なぜ無駄なのか？ それは `cp`
コマンドの終了ステータスで直接分岐すればいいことに対して、わざわざ 
`[`
コマンド（`test`
コマンドの別名）を使って、**終了ステータスを比較して終了ステータスを生成している**からです。`cp`
コマンドが正常終了したか調べるために、わざわざ別の `test` (`[`)
コマンドを呼び出して調べるのは無駄な処理でしよう。

ここで少したち止まって考えて欲しいのですが「終了ステータスを 0
と比較する」のは本当にあなたがやりたいことなのでしょうか？
おそらく違うはずです。本当にやりたいことはコマンドの実行が正常終了したかで分岐することであって、終了ステータスの値なんかどうでも良いはずです。

[NOTE]
====

以下のような書き方もできますが、`&&` と `||`
が混在した三項演算子風の書き方は基本的に避けることを推奨します。

[.bold]**基本的には避けた方が良い記法**

....
cp from to && echo "コピーに成功しました" || echo "コピーに失敗しました"
....

なぜなら A && B || C の時、A が成功して B が失敗すると C
が実行されてしまうからです。この書き方が成立するのは B
が必ず正常終了する場合のみです。ほとんどの場合 `echo`
コマンドは正常終了するのですが、標準出力が閉じられている場合や、`alias`
やシェル関数で置き換えられているときに失敗する可能性があります。私はこの書き方を単純な変数代入にのみ使用するようにしています。*コマンド置換を伴わない限り*、変数代入が失敗することはありません。

[.bold]#私はこのパターンで記述します。#

....
cp from to && msg="cpに成功" || msg="cpに失敗"; echo $msg
....
====

== ShellCheck を使おうかい！

`[ $? -eq 0 ]` や `[ $? -ne 0 ]`
を書くのをやめようと言っているのは、私だけではありません。良いシェルスクリプトを書くのに必須の
ShellCheck でも同じように指摘されます。

....
$ shellcheck script.sh

In script.sh line 4:
if [ $? -eq 0 ]; then
     ^-- SC2181 (style): Check exit code directly with e.g. 
       'if mycmd;', not indirectly with $?.

For more information:
  https://www.shellcheck.net/wiki/SC2181 -- Check exit code directly with e.g...
....

詳細な理由は以下参照

`[ $? -eq 0 ]` や `[ $? -ne 0 ]`を書くのをやめる？
そんなルール聞いた事ないと言う人は ShellCheck
を使っていないことの証拠です。良いシェルスクリプトの書き方を ShellCheck
を使って学んでください。

== if...thenは他の言語のtry...catchに近い

JavaScript などの言語は `try ... catch`
と呼ばれる例外処理の機能を持っています。

....
try {
  // 例外が発生する可能性がある処理
} catch (error) {
  // 例外が発生した時の処理
}
....

`try ... catch`
は数値などを比較する機能ではなくエラー処理のための機能であることは明白ですが、実はシェル言語の
`if` はどちらかと言えば `try ... catch` に近い機能なのです。`if`
の改行の位置を変えるとこのようになります。

....
if
   # エラーが発生する可能性がある処理
then
   # エラーが発生しない時の処理
else
   # エラーが発生した時の処理
fi
....

`if ... then` は、JavaScript の `try ... catch` と同じように `...`
の間に複数の処理（関数やコマンド）を書くことができます。

[.bold]#ifとthenの間に複数のコマンドを書くことができる#

....
if
   echo "step1"
   echo "step2"
   echo "step3"
then
   :
fi
....

残念ながら複数のコマンドを書いたとしても、`if`
は最後に実行したコマンドの終了ステータスしか参照しないので意味はありませんが、`if`
と `then`
の間には**どんなものでも書くことができる**ということを覚えておいてください。例えば以下のようなコードを書くことができ、そのコードのエラー処理を行うことができます。

[.bold]#コマンド置換のエラー処理を行うことができる#

....
if now=$(date); then
  echo "現在日時は $now です"
else
  echo "エラーで now を取得できませんでした"
fi
....

[.bold]#パイプラインのエラー処理を行うことができる#

....
if echo "step1" | grep "e"; then
  echo "文字列 e が見つかりました"
else
  echo "文字列 e が見つかりません"
fi
....

[NOTE]
====
##

パイプラインのエラー処理の補足ですが、デフォルトではパイプラインの最後のコマンド（上記の例では
`grep`
コマンド）の終了ステータスしか参照しないので注意してください。いずれかのコマンドでエラーになったことを検出したい場合は
`set -o pipefail`
を有効にしてください。有効にすると最後にエラーになったコマンドの終了ステータスを参照するようになります。

bash と mksh 専用の **`PIPESTATUS`
変数は（どうしても必要がない限り）使用しない**でください（zsh の
`pipestatus` も同様）。`PIPESTATUS` 変数が使えるのであれば
 POSIXで標準化された`set -o pipefail` 利用し移植性を考慮します。
====

== $? を変数に保存する必要はない

`grep` コマンドは文字列が見つからないときに終了ステータスを 1
にし、エラーが発生したときに 2 にします。終了ステータスが 1 か 2
かで、文字列が見つからない場合とエラーを区別することができます。そこでこのようなコードを思いつくかもしれませんが、このコードは正しく動きません。

[NOTE]
====
##

終了ステータスがうまく取れないので意図した動きとならない

....
echo letters | grep '[' # 意図的にシングルクォートだとエラー発生する(正規表現)
if [ $? -eq 0 ]; then
  echo "文字列が見つかりました"
elif [ $? -eq 1 ]; then
  echo "文字列が見つかりません"
else
  # ここに来てほしいが、ここには来ない
  echo "エラーが発生しました（終了ステータス: $?）"
fi
# 補足: シングルクォートで文字を囲むと文字自体の意味を次の処理まで伝播し +
　　　　ダブルクォートで文字を囲むと、囲んだ文字自体を次処理まで伝播
....
====

上記のコードを実行するとエラーが発生しているのにエラーが発生したことを検出できません。なぜなら終了ステータスは
`[ ...(テスト構文)]` を実行したときに変更されてしまうからです。

[.bold]#エラーが発生しているのに「文字列が見つかりません」と出力される#

....
$ ./grep.bash
grep: Invalid regular expression
文字列が見つかりません
....

良いシェルスクリプトの書き方を知らない人は、この問題を `$?`
を変数に保存することで解決しようとします。

[.bold]#
終了ステータスが書き換わらないように変数に$?を保存する無駄なコード#
letters に適当な文字を代入してスクリプトを実行する。

....
echo letters | grep '['
rtn=$?
if [ $rtn -eq 0 ]; then  # $rtn == 0 文字比較だと想定
  echo "文字列が見つかりました"
elif [ $rtn -eq 1 ]; then
  echo "文字列が見つかりません"
else
  echo "エラーが発生しました（終了ステータス: $ret）"
fi
....

[.bold]#想定通り「エラーが発生しました」と出力される#

....
$ ./grep.bash
grep: Invalid regular expression
エラーが発生しました（終了ステータス: 2）
....

しかし、これは **`[ $? -eq 0 ]`
なんて無駄なコードを書くから、無駄に変数が必要になってしまっている**のです。良い書き方をすれば、`$?`　を変数に保存しないようにしましょう。（処理内容によっては変数保存する場合もあります）

== どう書くのかい？（2回目）

こうです。

[NOTE]
====
##

シンプルイズベスト

....
if echo letters | grep '['; then
  echo "文字列が見つかりました"
else
  case $? in
    1) echo "文字列が見つかりません" ;;
    2) echo "エラーが発生しました（終了ステータス: $?）" ;;
  esac
fi
....
====

なぜ、これで `$?` が書き換わらないのか？ その理由は `$?`
を参照するまでの間に他のコマンドを実行していないからです。もちろん次のような書き方でも構いません。

....
# set -e (errexit) を有効にしている場合は末尾に「&& :」をつける
# echo letters | grep '[' && :

echo letters | grep '['
case $? in
  0) echo "文字列が見つかりました" ;;
  1) echo "文字列が見つかりません" ;;
  2) echo "エラーが発生しました（終了ステータス: $?）" ;;
esac
....

無駄をなくせば無駄な変数は必要なくなり可読性も向上します。シェルスクリプトはよく設計されたプログラミング言語です。

補足ですが、`!` を使った場合は終了ステータスは取得できません。0
以外の終了ステータスは `!` の効果で反転されて、すべて 0
に変換されてしまうからです。

[.bold]#! を使うと終了ステータスを取得することはできない#

....
if ! echo letters | grep '['; then
  echo "then の終了ステータス: $?" # 必ず 0 
else
  echo "else の終了ステータス: $?" # 必ず 1 
fi
....

もし `then` で何もする必要がない場合は、何もしないコマンド `:`
を実行するか、`||` を使った少し異なる書き方をする必要があります。

[.bold]#then で何もする必要がない場合は、何もしないコマンド :
を実行する#

....
# 可読性を気にせず、短く書きたいなら以下の方法もある
if echo lsetters | grep '['; then
  : # POSIX 準拠で書く場合は then の中を省略することはできない
else
  echo "終了ステータス: $?" # 終了ステータスを取れる
fi

echo letters | grep '[' || {
  echo "終了ステータス: $?" # 終了ステータスを取れる
}
....


== Bourne シェルに `[ ...(test構文) ]` は必須ではない

`if` とよく組み合わせて使う `[ ... ]` は、実際には **`[`
コマンドで、`test` コマンドの別名**です。もともと Bourne シェルでは
`test` (`[`) コマンドは外部コマンドで、`/bin/test` (`/bin/[`)
という実行ファイルを呼び出していました。後期の Bourne シェルでは `test`
(`[`) コマンド はシェルに組み込まれ、現在の Bourne
シェル後継のシェルはすべてシェルに組み込んでいますが、もともとの設計では
**`test` (`[`)
コマンドはシェルに組み込むまでもない重要ではないコマンド**でした。

外部コマンドの呼び出しはシェルにとって遅い処理です。Bourne
シェルはパフォーマンスを考慮して設計されており、遅くなるようであれば最初から対策していたはずです。`test`
(`[`)
コマンドはコマンドを実行した後の**エラー処理に使うものではない**ので、あまり使わない機能はシェルに組み込む必要がないというのが当初の設計上の判断だったのでしょう。もちろんファイル属性などの比較（`[ -f file.txt ]`
など）には使いますが、そこまで必要なものではありませんよね？また文字列の比較には
`case` を使えば十分です。

なぜ `[ $? -eq 0 ]` のような書き方が広まってしまったのでしょうか？
その原因の一つは C シェルにあるかもしれません。C シェルの `if`
はコマンドを実行することができず、変数の値を評価するものなので次のように書くことしかできません。

[.bold]#C シェルでの書き方#

....
cp from to
if ($status == 0) then
  echo "コピーに成功しました"
else
  echo "コピーに失敗しました"
endif
....

昔、 C シェルがメジャーだったので、この書き方を Bourne シェルでも同じになったかもしれません。C シェルは Bourne シェルよりも速いと言われていたので、いちいち終了ステータスを
0 と比較するコードで比較していたからと思われます。0
との比較はシェルに機能が組み込まれている C シェルでは速く、昔の Bourne
シェルでは遅い書き方です。Bourne シェルでは不要な処理で、シェルに数値比較の機能が組み込まれた今は昔の話ですが、
Bourne シェル用に無駄のないコードを書いていれば、Bourne 
シェルは速かったのです。`test` (`[`)
コマンドがシェルに組み込まれた理由には、C
シェルのような書き方をしても問題ないようにするためだったのかもしれません。

Bourne シェルと C
シェルは、ほぼ同じ時期に開発されたシェルです。時系列については以下の記事を参照してください。

link::https://qiita.com/ko1nksm/items/81233a6bf37279e70223

== シェル言語の、ifとcaseは根本的に違う

`if` と `case` を似たような機能だと思っていないでしょうか？

* `if` はコマンドを実行して、その成否で処理を分岐する機能です
* `case` は文字列を比較する機能です

「コマンドの実行」と「文字列の比較」。**シェル言語にとっては**この 2
つは全く別の機能です。シェル言語の `if`
はコマンドを実行し、そのコマンドの実行が正常終了したかエラー終了したかで処理を分岐できるように設計されています。

`[ $? -eq 0 ]` や `[ $? -ne 0 ]`
をなくすことのもう一つのメリットは、シェルスクリプトは 0 が真だっけ？ 1
が真だっけ？
と悩まなくて良くなることです。*シェル言語も他の言語と同じように真は
1（正確には 0 以外）*
です。そして他の言語でもプログラムが正常終了したときの終了ステータスは 0
です。

[.bold]#真となる計算式の値は1であることがわかる#

....
$ echo $(( 5 < 10 ))
1
....

シェル言語の `if`
は実行したコマンドの成否（つまり終了ステータス）で分岐するものだということを理解することで、シェル言語は真偽値を示す数値が反対とかいう的はずれな話を忘れることができます。

== [#whileでは----eq-0--を省略してるよね .fragment]##link:++#while%E3%81%A7%E3%81%AF----eq-0--%E3%82%92%E7%9C%81%E7%95%A5%E3%81%97%E3%81%A6%E3%82%8B%E3%82%88%E3%81%AD++[__]whileでは [ $? -eq 0 ] を省略してるよね？

この記事の話は `while`（や
`until`）にも当てはまります。典型的なファイル読み込みのコードは、`read`
コマンドを実行して成功する限り繰り返すという意味です。

[.bold]#ファイル（標準入力）を読み込んで行数をカウントするコード#

....
count=0

# while は read コマンドを実行し、成功する限り繰り返す
while read -r line; do
  count=$((count + 1))
done

echo "$count"
....

`while` でいつもやっていることなのだから、`if` で`[ $? -eq 0 ]` や
`[ $? -ne 0 ]`
の省略することが、難しい（理解できない）ってことはないでしょう。

[.bold]#誰もこんなコード書かないじゃないですか？#

....
while read -r line; [ $? -eq 0 ]; do
  count=$((count + 1))
done
....

`[ $? -eq 0 ]` や `[ $? -ne 0 ]`
は省略したほうが簡潔でわかりやすいんです。

== [#さいごに .fragment]##link:#%E3%81%95%E3%81%84%E3%81%94%E3%81%AB[__]さいごに

どんな場合でも `[ $? -eq 0 ]` や `[ $? -ne 0 ]`
を使ってはダメだとまで言うつもりはありませんが（実際私もごく稀な例で使っている場合があります）、本来は必要ないということを忘れないようにしてください。終了ステータスを変数に代入しなければならないのであれば、不必要に冗長なコードである可能性が高いです。シェルは簡潔に正しくコマンド実行のエラー処理をかけるように設計されています。しかしそれも良い書き方を知らなければ台無しになってしまいます。


